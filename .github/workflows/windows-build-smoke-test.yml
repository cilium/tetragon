name: Windows Build and Smoke
on:
  pull_request:
    paths-ignore:
      - docs/**
  push:
    branches:
      - main
      - v*
    paths-ignore:
      - docs/**
jobs:
  windows-ebpf-prog-build:
    name: Build Windows process ebpf program
    runs-on: windows-2022
    timeout-minutes: 25

    env:
      GOCACHE: D:\gocache
      GOMODCACHE: D:\gomodcache
      TEMP: D:\temp
      CI_EFW_VERSION: 0.20.0
      BUILD_CONFIGURATION: Release
      BUILD_PLATFORM: x64

    steps:
      - name: Create Temp Directory
        run: mkdir D:\temp
        shell: pwsh

      - name: Checkout Tetragon Repo 
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          path: go/src/github.com/cilium/tetragon/

      - name: Install LLVM 18.1.8
        run: |
          # Install LLVM 18.1.8 to ensure consistent version across runners
          try {
            choco install llvm --version=18.1.8 --allow-downgrade --force -y
            # Add installed LLVM to PATH first so it takes precedence
            echo "C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
            Write-Host "Successfully installed LLVM 18.1.8"
          } catch {
            Write-Warning "Failed to install LLVM 18.1.8 via chocolatey: $($_.Exception.Message)"
            Write-Host "Continuing with pre-installed LLVM version"
          }

      - name: Set MSVC Environment Variables
        shell: cmd
        run: |
          call "C:\Program Files\Microsoft Visual Studio\2022\Enterprise\VC\Auxiliary\Build\vcvars64.bat"
          powershell.exe "echo 'msvc_tools_path=%VCToolsInstallDir%' | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append"
          powershell.exe "echo 'msvc_tools_version=%VCToolsVersion%' | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append"
          powershell.exe "echo 'ASAN_WIN_CONTINUE_ON_INTERCEPTION_FAILURE=true' | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append"
          powershell.exe "echo 'VCINSTALLDIR=%VCINSTALLDIR%' | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append"

      - name: Add MSBuild to PATH
        uses: microsoft/setup-msbuild@767f00a3f09872d96a0cb9fcd5e6a4ff33311330
        with:
          msbuild-architecture: x64
      
      - name: Add Visual Studio LLVM to path
        run: |
          echo "$env:VCINSTALLDIR\tools\llvm\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Check for Clang version (MSVC)
        run:
          clang.exe --version

      - name: Check clang version (LLVM)
        shell: cmd
        run:
            '"c:\Program Files\llvm\bin\clang.exe" --version'

      - name: Download ntosebpfext 
        id: download-ntosebpfet
        shell: powershell
        working-directory: ${{ env.TEMP }}
        run: | 
          git clone --recursive https://github.com/microsoft/ntosebpfext.git
          cd ${{ env.TEMP }}\ntosebpfext
          git checkout e7dc209a8be0da2ff5d75f5772a0ee0bf4a10383
      
      - name: Copy Process_monitor.c file
        run: |
            $sourcePath = "${{ github.workspace }}\go\src\github.com\cilium\tetragon\bpf\windows\process_monitor.c"
            $destinationPath = "${{ env.TEMP }}\ntosebpfext\tools\process_monitor_bpf\process_monitor.c"
            Copy-Item -Path $sourcePath -Destination $destinationPath -Force
        shell: powershell

      - name: Configuring repo for first build
        working-directory: ${{ env.TEMP }}\ntosebpfext
        env:
          CXXFLAGS: /ZH:SHA_256 ${{ env.CXX_FLAGS }}
          LDFLAGS: ${{ env.LD_FLAGS }}
        run: |
            .\scripts\initialize_repo.ps1
 
      - name: Build Process monitor ebpf program
        working-directory: ${{ env.TEMP }}\ntosebpfext
        run: msbuild -target:Tools\process_monitor_bpf:Rebuild /m /p:Configuration=${{env.BUILD_CONFIGURATION}} /p:Platform=${{env.BUILD_PLATFORM}} /bl:${{env.BUILD_PLATFORM}}_${{env.BUILD_CONFIGURATION}}\build_logs\build.binlog ${{env.BUILD_OPTIONS}} ${{env.SOLUTION_FILE_PATH}}

      - name: Zip Build Output
        working-directory: ${{ env.TEMP }}\ntosebpfext
        run: |
          Compress-Archive -Path ${{env.BUILD_PLATFORM}}\${{env.BUILD_CONFIGURATION}} -DestinationPath .\build-${{env.BUILD_PLATFORM}}.${{env.BUILD_CONFIGURATION}}.zip

      - name: Upload Build Output
        uses: actions/upload-artifact@de65e23aa2b7e23d713bb51fbfcb6d502f8667d8
        with:
          name: ntosebpfext-build-output
          path: ${{ env.TEMP }}\ntosebpfext\build-${{env.BUILD_PLATFORM}}.${{env.BUILD_CONFIGURATION}}.zip
          retention-days: 5

  windows-tetragon-build:
    name: Build and Upload Windows Tetragon and Tetra Binaries
    runs-on: windows-2022
    needs: windows-ebpf-prog-build
    timeout-minutes: 15
    env:
      TEMP: D:\temp
      GOARCH: amd64
      GOOS: windows

    steps:
      - name: Check versions
        shell: powershell
        run: |
          $PSVersionTable

      - name: Install Go
        uses: actions/setup-go@44694675825211faa026b3c33043df3e48a5fa00 # v6.0.0
        with:
          # renovate: datasource=golang-version depName=go
          go-version: '1.25.3'

      - name: Create Temp Directory
        run: mkdir D:\temp
        shell: powershell

      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          path: go/src/github.com/cilium/tetragon/
      
      - name: Build and Zip tetragon Windows binaries
        working-directory: ${{ github.workspace }}\go\src\github.com\cilium\tetragon
        shell: powershell
        run: |
          go build -o .\Tetra.exe .\cmd\tetra\ 
          go build -o .\Tetragon.exe .\cmd\tetragon\
          Get-ChildItem
          New-Item -ItemType Directory -Path ${{ env.TEMP }}\Tetragon-Windows
          Copy-Item *.exe -Destination ${{ env.TEMP }}\Tetragon-Windows
          Compress-Archive -Path ${{ env.TEMP }}\Tetragon-Windows\* -DestinationPath ${{ env.TEMP }}\Tetragon-Windows.zip
          Get-ChildItem -Recurse ${{ env.TEMP }} 

      - name: Upload Tetragon Windows binaries
        uses: actions/upload-artifact@de65e23aa2b7e23d713bb51fbfcb6d502f8667d8
        with:
          name: tetragon-windows-build-output
          path: ${{ env.TEMP }}\Tetragon-Windows.zip
          retention-days: 5

  windows-smoke-test:
    name: Deploy and Test tetragon for Windows 
    runs-on: windows-2022
    needs:
      - windows-tetragon-build
      - windows-ebpf-prog-build
    timeout-minutes: 15
    strategy:
      matrix:
        version:
          - main
    env:
      TEMP: D:\temp
      
    steps:
      - name: Create Temp Directory
        run: mkdir D:\temp
        shell: powershell
      
      - name: Create Temp Staging Directory
        run: mkdir D:\temp\test
        shell: powershell

      - name: Cache eBPF for Windows installer
        id: cache-ebpf-installer
        uses: actions/cache@0400d5f644dc74513175e3cd8d07132dd4860809 # v4.2.4
        with:
          path: D:\temp\efw.zip
          key: ${{ runner.os }}-ebpf-installer-v0.21.0

      - name: Download and Install eBPF for Windows
        shell: powershell
        run: |
          function Test-ZipFile {
              param([string]$FilePath)
              try {
                  Add-Type -AssemblyName System.IO.Compression.FileSystem
                  $zip = [System.IO.Compression.ZipFile]::OpenRead($FilePath)
                  $isValid = $zip.Entries.Count -ge 0
                  $zip.Dispose()
                  return $isValid
              }
              catch {
                  return $false
              }
          }

          $zipPath = "D:\temp\efw.zip"
          $zipCached = $false

          if (Test-Path $zipPath) {
              $fileInfo = Get-Item $zipPath
              Write-Host "Cached ZIP file found, size: $($fileInfo.Length) bytes"
              
              if (Test-ZipFile $zipPath) {
                  $zipCached = $true
              } else {
                  Write-Warning "Invalid or corrupted cached ZIP file found, removing"
                  Remove-Item $zipPath -Force
              }
          }

          $maxRetries = 3
          $retryCount = 0
          $downloadUrl = "https://github.com/microsoft/ebpf-for-windows/releases/download/Release-v0.21.0/Build-native-only.NativeOnlyRelease.x64.zip"
          $extractPath = "D:\temp"
          $ebpfPath = "D:\temp\ebpf"

          while (-not $zipCached -and ($retryCount -lt $maxRetries)) {
              try {
                  Write-Host "Download attempt $($retryCount + 1) of $maxRetries..."
                  
                  # Use WebClient instead of Invoke-WebRequest
                  $webClient = New-Object System.Net.WebClient
                  $webClient.Headers.Add("User-Agent", "PowerShell/5.1")
                  $webClient.DownloadFile($downloadUrl, $zipPath)
                  $webClient.Dispose()
                  
                  # Validate the download
                  if (Test-Path $zipPath) {
                      $fileInfo = Get-Item $zipPath
                      Write-Host "Downloaded file size: $($fileInfo.Length) bytes"
                      
                      if (Test-ZipFile $zipPath) {
                          $zipCached = $true
                          break
                      } else {
                          Write-Warning "Invalid or corrupted ZIP file detected"
                          Remove-Item $zipPath -Force
                      }
                  } else {
                      Write-Warning "Download file not found after download attempt"
                  }
              }
              catch {
                  Write-Warning "Download attempt failed: $($_.Exception.Message)"
                  if ($webClient) { $webClient.Dispose() }
                  if (Test-Path $zipPath) {
                      Remove-Item $zipPath -Force
                  }
              }
              
              $retryCount++
              if ($retryCount -lt $maxRetries) {
                  Write-Host "Waiting 5 seconds before retry..."
                  Start-Sleep -Seconds 5
              }
          }

          # Final validation before proceeding
          if (-not (Test-Path $zipPath)) {
              throw "Download failed after $maxRetries attempts."
          }

          try {
              Write-Host "Extracting archive to $extractPath..."
              Expand-Archive -Path $zipPath -DestinationPath $extractPath -Force -ErrorAction Stop
          }
          catch {
              Write-Error "Failed to extract archive: $($_.Exception.Message)"
              throw
          }

          # Rename the extracted directory
          $originalPath = "D:\temp\Build-native-only NativeOnlyRelease x64"
          if (Test-Path $originalPath) {
              try {
                  Rename-Item -Path $originalPath -NewName $ebpfPath -ErrorAction Stop
              }
              catch {
                  Write-Error "Failed to rename directory: $($_.Exception.Message)"
                  throw
              }
          } else {
              Write-Error "Expected directory not found: $originalPath"
              Get-ChildItem -Path $extractPath -Directory | ForEach-Object { Write-Host "Found directory: $($_.FullName)" }
              throw "Extraction directory structure is not as expected"
          }

          # Find and execute the setup script
          Write-Host "Searching for setup script..."
          $setupScript = Get-ChildItem -Path $ebpfPath -Filter "setup-ebpf.ps1" -Recurse | Select-Object -First 1

          if ($setupScript) {
              Write-Host "Found setup script: $($setupScript.FullName)"
              
              # Change to the script directory
              $originalLocation = Get-Location
              try {
                  Set-Location -Path $setupScript.DirectoryName
                  Write-Host "Changed directory to: $(Get-Location)"
                  
                  # Execute the setup script
                  Write-Host "Executing setup script..."
                  & $setupScript.FullName
                  
                  Write-Host "Setup script execution completed"
              }
              catch {
                  Write-Error "Failed to execute setup script: $($_.Exception.Message)"
                  throw
              }
              finally {
                  # Restore original location
                  Set-Location -Path $originalLocation
              }
          } else {
              Write-Error "Setup script 'setup-ebpf.ps1' not found in the extracted package"
              Write-Host "Directory contents:"
              Get-ChildItem -Path $ebpfPath -Recurse | ForEach-Object { 
                  Write-Host "  $($_.FullName)" 
              }
              throw
          }

          Write-Host "Script execution completed successfully"

      - name: Add eBPF for Windows to PATH
        shell: pwsh
        run: echo "C:\Program Files\ebpf-for-windows\" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Download tetragon-windows-build-output
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          path: ${{ env.TEMP }}\test
          name: tetragon-windows-build-output
      
      - name: Download ntosebpfext-build-output
        uses: actions/download-artifact@634f93cb2916e3fdff6788551b99b062d0335ce0 # v5.0.0
        with:
          path: ${{ env.TEMP }}\test
          name: ntosebpfext-build-output
    
      - name: Checkout
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v5.0.0
        with:
          path: go/src/github.com/cilium/tetragon/

      - name: Setup Tetragon for Windows 
        working-directory: ${{ github.workspace }}\go\src\github.com\cilium\tetragon
        shell: powershell
        run: ${{ github.workspace }}\go\src\github.com\cilium\tetragon\install\windows\setup-windows.ps1 ${{ env.TEMP }}\test\Tetragon-Windows.zip ${{ env.TEMP }}\test\build-x64.Release.zip 

      - name: Run Smoke test Windows
        env:
          TEMP: D:\temp
          PATH: ${{ env.TEMP }};"C:\Program Files\ebpf-for-windows"
        working-directory: C:\Program Files\Tetragon\cmd
        shell: powershell
        run: |
          $jsonFilePath = "C:\Program Files\Tetragon\events.json"

          # Define the path to the executable
          $tetragonProcess = "C:\Program Files\Tetragon\cmd\tetragon.exe"

          # Start the process in the background and capture its PID
          $tetragonBackgroundProcess = Start-Process -FilePath "$tetragonProcess" -ArgumentList "--export-filename ""$jsonFilePath""" -RedirectStandardOutput "C:\Program Files\Tetragon\tetragon.log" -NoNewWindow -PassThru
          Start-Sleep -Seconds 5
          if(Get-Process -id $tetragonBackgroundProcess.Id) {
            Write-Host "Tetragon is Running "
          }
          else {
            throw "Tetragon Could not be started"
          }

          $notepad = Start-Process -FilePath "C:\Windows\System32\notepad.exe" -PassThru
          $notepadPID = $notepad.Id
          Write-Host "Process launched with PID: $notepadPID"

          $searchString = "\{\""process_exec\""\:\{\""process\""\:\{\""exec_id\""\:\"".{16,30}\""\,.{0,1}\""pid\""\:$notepadPID\,.{0,1}\""uid\""\:[0-9]{0,9}\,.{0,1}\""binary\""\:\""C:\\\\Windows\\\\system32\\\\notepad.exe\"""

          Write-Host "Looking for regex: $searchString"
          # Load the JSON content
          $jsonContent = Get-Content -Path $jsonFilePath 

          # Search for the PID in the JSON file
          if ($jsonContent -match $searchString) {
              Write-Host "Found PID $notepadPID in JSON file: $searchString"
          } else {
              Write-Host "PID $notepadPID not found in event file: $jsonContent "
              throw "PID not found in event JSON file."
          }
