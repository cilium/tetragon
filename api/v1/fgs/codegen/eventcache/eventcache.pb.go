// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

// Code generated by protoc-gen-go-tetragon. DO NOT EDIT

package eventcache

import (
	fmt "fmt"
	fgs "github.com/cilium/tetragon/api/v1/fgs"
	metrics "github.com/cilium/tetragon/pkg/metrics"
	process "github.com/cilium/tetragon/pkg/process"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type eventObj interface {
	GetProcess() *fgs.Process
}

func DoHandleEvent(event eventObj, internal *process.ProcessInternal, labels []string, nodeName string, timestamp *timestamppb.Timestamp) (*fgs.GetEventsResponse, error) {
	switch e := event.(type) {

	case *fgs.ProcessExec:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessExec").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessExec{ProcessExec: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessExit:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessExit").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessExit{ProcessExit: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessKprobe:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessKprobe").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessKprobe{ProcessKprobe: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessTracepoint:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessTracepoint").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessTracepoint{ProcessTracepoint: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessDns:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessDns").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessDns{ProcessDns: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil
	}
	return nil, fmt.Errorf("DoHandleEvent: Unhandled event type %T", event)
}
