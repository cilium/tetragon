//  Copyright (C) Isovalent, Inc. - All Rights Reserved.
//
//  NOTICE: All information contained herein is, and remains the property of
//  Isovalent Inc and its suppliers, if any. The intellectual and technical
//  concepts contained herein are proprietary to Isovalent Inc and its suppliers
//  and may be covered by U.S. and Foreign Patents, patents in process, and are
//  protected by trade secret or copyright law.  Dissemination of this information
//  or reproduction of this material is strictly forbidden unless prior written
//  permission is obtained from Isovalent Inc.
//

// Code generated by protoc-gen-go-tetragon. DO NOT EDIT

package eventcache

import (
	fmt "fmt"
	fgs "github.com/cilium/tetragon/api/v1/fgs"
	metrics "github.com/cilium/tetragon/pkg/metrics"
	process "github.com/cilium/tetragon/pkg/process"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type eventObj interface {
	GetProcess() *fgs.Process
}

func DoHandleEvent(event eventObj, internal *process.ProcessInternal, labels []string, nodeName string, timestamp *timestamppb.Timestamp) (*fgs.GetEventsResponse, error) {
	switch e := event.(type) {

	case *fgs.ProcessExec:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessExec").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessExec{ProcessExec: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessExit:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessExit").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessExit{ProcessExit: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessKprobe:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessKprobe").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessKprobe{ProcessKprobe: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessTracepoint:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessTracepoint").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessTracepoint{ProcessTracepoint: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *fgs.ProcessDns:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessDns").Inc()
			metrics.ErrorCount.WithLabelValues(string(metrics.EventCacheProcessInfoFailed)).Inc()
		}
		return &fgs.GetEventsResponse{
			Event:    &fgs.GetEventsResponse_ProcessDns{ProcessDns: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil
	}
	return nil, fmt.Errorf("DoHandleEvent: Unhandled event type %T", event)
}
