// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

// Code generated by protoc-gen-go-tetragon. DO NOT EDIT

package eventcache

import (
	fmt "fmt"
	tetragon "github.com/cilium/tetragon/api/v1/tetragon"
	metrics "github.com/cilium/tetragon/pkg/metrics"
	errormetrics "github.com/cilium/tetragon/pkg/metrics/errormetrics"
	process "github.com/cilium/tetragon/pkg/process"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
)

type eventObj interface {
	GetProcess() *tetragon.Process
}

func DoHandleEvent(event eventObj, internal *process.ProcessInternal, labels []string, nodeName string, timestamp *timestamppb.Timestamp) (*tetragon.GetEventsResponse, error) {
	switch e := event.(type) {

	case *tetragon.ProcessExec:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessExec").Inc()
			errormetrics.ErrorTotalInc(errormetrics.EventCacheProcessInfoFailed)
		}
		return &tetragon.GetEventsResponse{
			Event:    &tetragon.GetEventsResponse_ProcessExec{ProcessExec: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *tetragon.ProcessExit:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessExit").Inc()
			errormetrics.ErrorTotalInc(errormetrics.EventCacheProcessInfoFailed)
		}
		return &tetragon.GetEventsResponse{
			Event:    &tetragon.GetEventsResponse_ProcessExit{ProcessExit: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *tetragon.ProcessKprobe:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessKprobe").Inc()
			errormetrics.ErrorTotalInc(errormetrics.EventCacheProcessInfoFailed)
		}
		return &tetragon.GetEventsResponse{
			Event:    &tetragon.GetEventsResponse_ProcessKprobe{ProcessKprobe: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *tetragon.ProcessTracepoint:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessTracepoint").Inc()
			errormetrics.ErrorTotalInc(errormetrics.EventCacheProcessInfoFailed)
		}
		return &tetragon.GetEventsResponse{
			Event:    &tetragon.GetEventsResponse_ProcessTracepoint{ProcessTracepoint: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil

	case *tetragon.ProcessDns:
		if internal != nil {
			e.Process = internal.GetProcessCopy()
		} else {
			metrics.ProcessInfoErrors.WithLabelValues("ProcessDns").Inc()
			errormetrics.ErrorTotalInc(errormetrics.EventCacheProcessInfoFailed)
		}
		return &tetragon.GetEventsResponse{
			Event:    &tetragon.GetEventsResponse_ProcessDns{ProcessDns: e},
			NodeName: nodeName,
			Time:     timestamp,
		}, nil
	}
	return nil, fmt.Errorf("DoHandleEvent: Unhandled event type %T", event)
}
