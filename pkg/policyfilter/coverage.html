
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>policyfilter: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/cilium/tetragon/pkg/policyfilter/cgroupid.go (0.0%)</option>
				
				<option value="file1">github.com/cilium/tetragon/pkg/policyfilter/debug.go (25.0%)</option>
				
				<option value="file2">github.com/cilium/tetragon/pkg/policyfilter/dummy.go (0.0%)</option>
				
				<option value="file3">github.com/cilium/tetragon/pkg/policyfilter/map.go (71.6%)</option>
				
				<option value="file4">github.com/cilium/tetragon/pkg/policyfilter/podhelpers.go (93.3%)</option>
				
				<option value="file5">github.com/cilium/tetragon/pkg/policyfilter/policyfilter.go (0.0%)</option>
				
				<option value="file6">github.com/cilium/tetragon/pkg/policyfilter/state.go (79.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

package policyfilter

import (
        "errors"

        "github.com/cilium/tetragon/pkg/cgroups"
        "github.com/cilium/tetragon/pkg/cgroups/fsscan"
        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
)

type cgidFinder interface {
        findCgroupID(podID PodID, containerID string) (CgroupID, error)
}

type cgfsFinder struct {
        fsscan.FsScanner
        log logrus.FieldLogger
}

func (s *cgfsFinder) findCgroupID(podID PodID, containerID string) (CgroupID, error) <span class="cov0" title="0">{
        path, err := s.FindContainerPath(uuid.UUID(podID), containerID)
        if errors.Is(err, fsscan.ErrContainerPathWithoutMatchingPodID) </span><span class="cov0" title="0">{
                s.log.WithFields(logrus.Fields{
                        "pod-id":       podID,
                        "container-id": containerID,
                }).Info("FindCgroupID: found path without matching pod id, continuing.")
        }</span> else<span class="cov0" title="0"> if err != nil </span><span class="cov0" title="0">{
                return CgroupID(0), err
        }</span>
        <span class="cov0" title="0">cgid, err := cgroups.GetCgroupIdFromPath(path)
        return CgroupID(cgid), err</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

package policyfilter

import (
        "fmt"
        "io"
        "runtime"

        "github.com/cilium/tetragon/pkg/option"
        "github.com/sirupsen/logrus"
)

// there is no way to have selective information level  per sub-system
// (see: https://github.com/cilium/cilium/issues/21002) so we define a flag and
// some helper functions here.

func initEmptylogger() logrus.FieldLogger <span class="cov8" title="1">{
        // NB: we could define a better empty logger, that also ignores WithField
        log := logrus.New()
        log.SetOutput(io.Discard)
        return log
}</span>

var (
        emptyLogger = initEmptylogger()
)

func (s *state) debugLogWithCallers(nCallers int) logrus.FieldLogger <span class="cov8" title="1">{
        if !option.Config.EnablePolicyFilterDebug </span><span class="cov8" title="1">{
                return emptyLogger
        }</span>

        <span class="cov0" title="0">log := s.log
        for i := 1; i &lt;= nCallers; i++ </span><span class="cov0" title="0">{
                pc, _, _, ok := runtime.Caller(i)
                if !ok </span><span class="cov0" title="0">{
                        return log
                }</span>
                <span class="cov0" title="0">fn := runtime.FuncForPC(pc)
                key := fmt.Sprintf("caller-%d", i)
                log = log.WithField(key, fn.Name())</span>
        }

        <span class="cov0" title="0">return log</span>
}

func (s *state) Debug(args ...interface{}) <span class="cov0" title="0">{
        if option.Config.EnablePolicyFilterDebug </span><span class="cov0" title="0">{
                s.log.Info(args...)
        }</span> else<span class="cov0" title="0"> {
                s.log.Debug(args...)
        }</span>
}

func (s *state) Debugf(fmt string, args ...interface{}) <span class="cov0" title="0">{
        if option.Config.EnablePolicyFilterDebug </span><span class="cov0" title="0">{
                s.log.Infof(fmt, args...)
        }</span> else<span class="cov0" title="0"> {
                s.log.Debugf(fmt, args...)
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon
package policyfilter

import (
        "fmt"

        slimv1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/meta/v1"
        "github.com/cilium/tetragon/pkg/labels"
        "k8s.io/client-go/tools/cache"
)

type dummy struct {
}

func (s *dummy) AddPolicy(polID PolicyID, namespace string, podSelector *slimv1.LabelSelector) error <span class="cov0" title="0">{
        return fmt.Errorf("policyfilter is disabled")
}</span>

func (s *dummy) DelPolicy(polID PolicyID) error <span class="cov0" title="0">{
        return fmt.Errorf("policyfilter is disabled")
}</span>

func (s *dummy) AddPodContainer(podID PodID, namespace string, podLabels labels.Labels, containerID string, cgIDp CgroupID) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *dummy) UpdatePod(podID PodID, namespace string, podLabels labels.Labels, containerIDs []string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *dummy) DelPodContainer(podID PodID, containerID string) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *dummy) DelPod(podID PodID) error <span class="cov0" title="0">{
        return nil
}</span>

func (s *dummy) RegisterPodHandlers(podInformer cache.SharedIndexInformer) {<span class="cov0" title="0">
}</span>

func (s *dummy) Close() error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

package policyfilter

import (
        "fmt"
        "os"
        "path"
        "path/filepath"
        "unsafe"

        "github.com/cilium/ebpf"
        "github.com/cilium/tetragon/pkg/bpf"
        "github.com/cilium/tetragon/pkg/kernels"
        "github.com/cilium/tetragon/pkg/option"
)

const (
        MapName = "policy_filter_maps"
)

// map operations used by policyfilter.

// PfMap is a simple wrapper for ebpf.Map so that we can write methods for it
type PfMap struct {
        *ebpf.Map
}

// newMap returns a new policy filter map.
func newPfMap() (PfMap, error) <span class="cov8" title="1">{
        // use the generic kprobe program, to find the policy filter map spec
        objName, _ := kernels.GenericKprobeObjs()
        objPath := path.Join(option.Config.HubbleLib, objName)
        spec, err := ebpf.LoadCollectionSpec(objPath)
        if err != nil </span><span class="cov0" title="0">{
                return PfMap{}, fmt.Errorf("loading spec for %s failed: %w", objPath, err)
        }</span>
        <span class="cov8" title="1">policyMapSpec, ok := spec.Maps[MapName]
        if !ok </span><span class="cov0" title="0">{
                return PfMap{}, fmt.Errorf("%s not found in %s", MapName, objPath)
        }</span>

        // bpf-side sets max_entries to 1. Later kernels (5.10) can deal with
        // inserting a different size of inner-map, but for older kernels, we
        // fix the spec here.
        <span class="cov8" title="1">policyMapSpec.InnerMap.MaxEntries = polMapSize

        ret, err := ebpf.NewMap(policyMapSpec)
        if err != nil </span><span class="cov0" title="0">{
                return PfMap{}, err
        }</span>

        <span class="cov8" title="1">mapDir := bpf.MapPrefixPath()
        pinPath := filepath.Join(mapDir, MapName)
        os.Remove(pinPath)
        os.Mkdir(mapDir, os.ModeDir)
        err = ret.Pin(pinPath)
        if err != nil </span><span class="cov0" title="0">{
                ret.Close()
                return PfMap{}, fmt.Errorf("failed to pin policy filter map in %s: %w", pinPath, err)
        }</span>

        <span class="cov8" title="1">return PfMap{ret}, err</span>
}

// release closes the policy filter bpf map and remove (unpin) the bpffs file
func (m PfMap) release() error <span class="cov8" title="1">{
        if err := m.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := m.Unpin(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// addPolicyMap adds and initializes a new policy map
func (m PfMap) newPolicyMap(polID PolicyID, cgIDs []CgroupID) (polMap, error) <span class="cov8" title="1">{
        name := fmt.Sprintf("policy_%d_map", polID)
        innerSpec := &amp;ebpf.MapSpec{
                Name:       name,
                Type:       ebpf.Hash,
                KeySize:    uint32(unsafe.Sizeof(CgroupID(0))),
                ValueSize:  uint32(1),
                MaxEntries: uint32(polMapSize),
        }

        inner, err := ebpf.NewMap(innerSpec)
        if err != nil </span><span class="cov0" title="0">{
                return polMap{}, fmt.Errorf("failed to create policy (id=%d) map: %w", polID, err)
        }</span>

        // update inner map with ids
        <span class="cov8" title="1">ret := polMap{inner}
        if err := ret.addCgroupIDs(cgIDs); err != nil </span><span class="cov0" title="0">{
                ret.Close()
                return polMap{}, fmt.Errorf("failed to update policy (id=%d): %w", polID, err)
        }</span>

        // update outer map
        // NB(kkourt): use UpdateNoExist because we expect only a single policy with a given id
        <span class="cov8" title="1">if err := m.Update(polID, uint32(ret.FD()), ebpf.UpdateNoExist); err != nil </span><span class="cov8" title="1">{
                ret.Close()
                return polMap{}, fmt.Errorf("failed to insert inner policy (id=%d) map: %w", polID, err)
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

func (m PfMap) readAll() (map[PolicyID]map[CgroupID]struct{}, error) <span class="cov8" title="1">{

        readInner := func(id uint32) (map[CgroupID]struct{}, error) </span><span class="cov8" title="1">{
                inMap, err := ebpf.NewMapFromID(ebpf.MapID(id))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error opening inner map: %w", err)
                }</span>
                <span class="cov8" title="1">defer inMap.Close()

                inIter := inMap.Iterate()
                var key CgroupID
                var val uint8

                ret := map[CgroupID]struct{}{}
                for inIter.Next(&amp;key, &amp;val) </span><span class="cov8" title="1">{
                        ret[key] = struct{}{}
                }</span>

                <span class="cov8" title="1">if err := inIter.Err(); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("error iterating inner map: %w", err)
                }</span>

                <span class="cov8" title="1">return ret, nil</span>

        }

        <span class="cov8" title="1">ret := make(map[PolicyID]map[CgroupID]struct{})
        var key PolicyID
        var id uint32

        iter := m.Iterate()
        for iter.Next(&amp;key, &amp;id) </span><span class="cov8" title="1">{
                cgids, err := readInner(id)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ret[key] = cgids</span>
        }

        <span class="cov8" title="1">if err := iter.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating outer map: %w", err)
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

// polMap is a simple wrapper for ebpf.Map so that we can write methods for it
type polMap struct {
        *ebpf.Map
}

type batchError struct {
        // SuccCount is the number of successful operations
        SuccCount int
        err       error
}

func (e *batchError) Error() string <span class="cov0" title="0">{
        return e.err.Error()
}</span>

func (e *batchError) Unwrap() error <span class="cov0" title="0">{
        return e.err
}</span>

// addCgroupIDs add cgroups ids to the policy map
// todo: use batch operations when supported
func (m polMap) addCgroupIDs(cgIDs []CgroupID) error <span class="cov8" title="1">{
        var zero uint8
        for i, cgID := range cgIDs </span><span class="cov8" title="1">{
                if err := m.Update(&amp;cgID, zero, ebpf.UpdateAny); err != nil </span><span class="cov0" title="0">{
                        return &amp;batchError{
                                SuccCount: i,
                                err:       fmt.Errorf("failed to update policy map (cgroup id: %d): %w", cgID, err),
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// addCgroupIDs delete cgroups ids from the policy map
// todo: use batch operations when supported
func (m polMap) delCgroupIDs(cgIDs []CgroupID) error <span class="cov8" title="1">{
        for i, cgID := range cgIDs </span><span class="cov8" title="1">{
                if err := m.Delete(&amp;cgID); err != nil </span><span class="cov0" title="0">{
                        return &amp;batchError{
                                SuccCount: i,
                                err:       fmt.Errorf("failed to delete items from policy map (cgroup id: %d): %w", cgID, err),
                        }
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func OpenMap(fname string) (PfMap, error) <span class="cov0" title="0">{
        m, err := ebpf.LoadPinnedMap(fname, &amp;ebpf.LoadPinOptions{
                ReadOnly: true,
        })

        if err != nil </span><span class="cov0" title="0">{
                return PfMap{}, err
        }</span>

        <span class="cov0" title="0">return PfMap{m}, err</span>
}

func (m PfMap) Dump() (map[PolicyID]map[CgroupID]struct{}, error) <span class="cov0" title="0">{
        return m.readAll()
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

package policyfilter

import (
        "strings"

        v1 "k8s.io/api/core/v1"
)

// podForAllContainers runs the given functions for all containers in a pod
func podForAllContainers(pod *v1.Pod, fn func(c *v1.ContainerStatus)) <span class="cov8" title="1">{
        run := func(s []v1.ContainerStatus) </span><span class="cov8" title="1">{
                for i := range s </span><span class="cov8" title="1">{
                        fn(&amp;s[i])
                }</span>
        }

        <span class="cov8" title="1">run(pod.Status.InitContainerStatuses)
        run(pod.Status.ContainerStatuses)
        run(pod.Status.EphemeralContainerStatuses)</span>
}

func containerIDFromContainerStatus(c *v1.ContainerStatus) string <span class="cov8" title="1">{
        ret := c.ContainerID
        if idx := strings.Index(ret, "://"); idx != -1 </span><span class="cov0" title="0">{
                ret = ret[idx+3:]
        }</span>
        <span class="cov8" title="1">return ret</span>
}

func podContainersIDs(pod *v1.Pod) []string <span class="cov8" title="1">{
        ret := make([]string, 0)
        podForAllContainers(pod, func(c *v1.ContainerStatus) </span><span class="cov8" title="1">{
                id := containerIDFromContainerStatus(c)
                ret = append(ret, id)
        }</span>)
        <span class="cov8" title="1">return ret</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon
package policyfilter

import (
        "sync"

        slimv1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/meta/v1"
        "github.com/cilium/tetragon/pkg/labels"
        "github.com/cilium/tetragon/pkg/logger"
        "github.com/cilium/tetragon/pkg/option"
        "k8s.io/client-go/tools/cache"
)

var (
        glblState   State
        glblError   error
        setGlobalPf sync.Once
)

// GetState returns global state for policyfilter
func GetState() (State, error) <span class="cov0" title="0">{
        setGlobalPf.Do(func() </span><span class="cov0" title="0">{
                if option.Config.EnablePolicyFilter </span><span class="cov0" title="0">{
                        logger.GetLogger().Info("Enabling policy filtering")
                        glblState, glblError = New()
                }</span> else<span class="cov0" title="0"> {
                        glblState = &amp;dummy{}
                        glblError = nil
                }</span>
        })
        <span class="cov0" title="0">return glblState, glblError</span>
}

// ResetStateOnlyForTesting resets the global policyfilter state.
// As the name states, it should only be used for testing.
// We need this because GetState() depends on the
// option.Config.EnablePolicyFilter global and this is only initialized once.
// Callers for this should ensure that no race happens.
func ResetStateOnlyForTesting() <span class="cov0" title="0">{
        if glblState != nil </span><span class="cov0" title="0">{
                glblState.Close()
        }</span>
        <span class="cov0" title="0">if option.Config.EnablePolicyFilter </span><span class="cov0" title="0">{
                logger.GetLogger().Info("Enabling policy filtering")
                glblState, glblError = New()
        }</span> else<span class="cov0" title="0"> {
                glblState = &amp;dummy{}
                glblError = nil
        }</span>
}

// State is the policyfilter state interface
// It handles two things:
//   - policies being added and removed
//   - pod containers being added and deleted.
type State interface {
        // AddPolicy adds a policy to the policyfilter state.
        // This means that:
        //  - existing containers of pods that match this policy will be added to the policyfilter map (pfMap)
        //  - from now on, new containers of pods that match this policy will also be added to pfMap
        // pods are matched with:
        //  - namespace for namespaced pilicies (if namespace == "", then policy is not namespaced)
        //  - label selector
        AddPolicy(polID PolicyID, namespace string, podSelector *slimv1.LabelSelector) error

        // DelPolicy removes a policy from the state
        DelPolicy(polID PolicyID) error

        // AddPodContainer informs policyfilter about a new container and its cgroup id in a pod.
        // The pod might or might not have been encountered before.
        // This method is intended to update policyfilter state from container hooks
        AddPodContainer(podID PodID, namespace string, podLabels labels.Labels, containerID string, cgID CgroupID) error

        // UpdatePod updates the pod state for a pod, where containerIDs contains all the container ids for the given pod.
        // This method is intended to be used from k8s watchers (where no cgroup information is available)
        UpdatePod(podID PodID, namespace string, podLabels labels.Labels, containerIDs []string) error

        // DelPodContainer informs policyfilter that a container was deleted from a pod
        DelPodContainer(podID PodID, containerID string) error
        // DelPod informs policyfilter that a pod has been deleted
        DelPod(podID PodID) error

        // RegisterPodHandlers can be used to register appropriate pod handlers to a pod informer
        // that for keeping the policy filter state up-to-date.
        RegisterPodHandlers(podInformer cache.SharedIndexInformer)

        // Close releases resources allocated by the Manager. Specifically, we close and unpin the
        // policy filter map.
        Close() error
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// SPDX-License-Identifier: Apache-2.0
// Copyright Authors of Tetragon

package policyfilter

import (
        "fmt"
        "sync"

        slimv1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/apis/meta/v1"
        "github.com/cilium/tetragon/pkg/cgroups/fsscan"
        "github.com/cilium/tetragon/pkg/labels"
        "github.com/cilium/tetragon/pkg/logger"
        "github.com/cilium/tetragon/pkg/podhooks"

        "github.com/google/uuid"
        "github.com/sirupsen/logrus"
        v1 "k8s.io/api/core/v1"
        "k8s.io/client-go/tools/cache"
)

// Policy filter is a mechanism for restricting  tracing policies on a subset
// of pods running in the node. Policies are identified by their policyID and
// the pod processes are identified the cgroup ids of their containers.
//
// The pods that match a given policy are selected based on:
//   (1) Namespaces
//   (2) Label filters
//
// This package maintains the 'policy_filter_maps' bpf map. Bpf checks this map
// to decide whether a policy is applied or not. The map is a hash-of-hashes:
//
//   policy_id -&gt; [ cgroup_id -&gt; u8 ]
//
// If entry policy_id -&gt; cgroup_id exists, then policy is to be applied. (u8 value is ignored for
// now.)
//
// This package provides functions that can be used to update the bpf map. The map
// needs to be updated in the following conditions:
//
//  (A) Policy changes: when a new policy is added (or deleted), we need to add cgroup ids of
//  matching pods. See {Add,Del}Policy.
//
//  (B) Pod containers changes: when new containers are added (or deleted): we need to add the cgroup
//  ids of matching policies. See AddPodContainer, DelPodContainer, DelPod.
//
//  (C) Pod labels change: need to rescan policies because the result of pod label filters might have
//  changed.
//
// Todo:
//  - use a goroutine and a queue
//  (https://github.com/kubernetes/client-go/blob/master/examples/workqueue/main.go) instead locks
//  for serilization

func init() <span class="cov8" title="1">{
        podhooks.RegisterCallbacksAtInit(podhooks.Callbacks{
                PodCallbacks: func(podInformer cache.SharedIndexInformer) </span><span class="cov0" title="0">{
                        // register pod handlers for policyfilters
                        if pfState, err := GetState(); err == nil </span><span class="cov0" title="0">{
                                logger.GetLogger().Info("registering policyfilter pod handlers")
                                pfState.RegisterPodHandlers(podInformer)
                        }</span>
                },
        })
}

const (
        // polMapSize is the number of entries for the (inner) policy map. It
        // should be large enough to accommodate the number of containers
        // running in a system.
        polMapSize = 32768
)

type PolicyID uint32
type PodID uuid.UUID
type CgroupID uint64

const (
        // we reserve 0 as a special value to indicate no filtering
        NoFilterPolicyID         = 0
        NoFilterID               = PolicyID(NoFilterPolicyID)
        FirstValidFilterPolicyID = NoFilterPolicyID + 1
)

func (i PodID) String() string <span class="cov8" title="1">{
        var x uuid.UUID = uuid.UUID(i)
        return x.String()
}</span>

type containerInfo struct {
        id   string   // container id
        cgID CgroupID // cgroup id
}

// podInfo contains the necessary information for each pod
type podInfo struct {
        id         PodID
        namespace  string
        labels     labels.Labels
        containers []containerInfo

        // cache of matched policies
        matchedPolicies []PolicyID
}

func (pod *podInfo) cgroupIDs() []CgroupID <span class="cov8" title="1">{
        ret := make([]CgroupID, 0, len(pod.containers))
        for i := range pod.containers </span><span class="cov8" title="1">{
                ret = append(ret, pod.containers[i].cgID)
        }</span>
        <span class="cov8" title="1">return ret</span>
}

// delete containers from a pod based on their id, and return them
// NB: in most cases there will be a single container, but we do not reject users adding a container
// with the same id and different cgroup, so we return a list to cover all cases.
func (pod *podInfo) delContainers(id string) []containerInfo <span class="cov8" title="1">{
        var ret []containerInfo
        for i := 0; i &lt; len(pod.containers); i++ </span><span class="cov8" title="1">{
                c := pod.containers[i]
                if c.id == id </span><span class="cov8" title="1">{
                        ret = append(ret, c)
                        pod.containers = append(pod.containers[:i], pod.containers[i+1:]...)
                        i--
                }</span>
        }
        <span class="cov8" title="1">return ret</span>
}

func (pod *podInfo) delCachedPolicy(polID PolicyID) <span class="cov8" title="1">{
        for i := 0; i &lt; len(pod.matchedPolicies); i++ </span><span class="cov8" title="1">{
                if pod.matchedPolicies[i] == polID </span><span class="cov8" title="1">{
                        pod.matchedPolicies = append(pod.matchedPolicies[:i], pod.matchedPolicies[i+1:]...)
                }</span>
        }
}

func (pod *podInfo) addCachedPolicy(polID PolicyID) <span class="cov8" title="1">{
        for i := 0; i &lt; len(pod.matchedPolicies); i++ </span><span class="cov8" title="1">{
                if pod.matchedPolicies[i] == polID </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">pod.matchedPolicies = append(pod.matchedPolicies, polID)</span>
}

func (pod *podInfo) hasPolicy(polID PolicyID) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(pod.matchedPolicies); i++ </span><span class="cov8" title="1">{
                if pod.matchedPolicies[i] == polID </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// containerExists checks returns true if a container exists in the pod
func (m *state) containerExists(pod *podInfo, containerID string, cgIDp *CgroupID) bool <span class="cov8" title="1">{
        for i := range pod.containers </span><span class="cov8" title="1">{
                container := &amp;pod.containers[i]
                if container.id != containerID </span><span class="cov8" title="1">{
                        continue</span>
                }

                // we found a matching container id, if no cgroup id is given, return
                <span class="cov0" title="0">if cgIDp == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                // otherwise, also check that the cgroup id matches
                <span class="cov0" title="0">if container.id == containerID &amp;&amp; container.cgID == *cgIDp </span><span class="cov0" title="0">{
                        // container was already handled, return
                        return true
                }</span>

                // issue  a warning and continue
                // NB: if this happens, we might end up with multiple cgroup
                // ids for the same container. Since we have no way of knowing
                // which one is the correct, we keep both.
                <span class="cov0" title="0">m.log.WithFields(logrus.Fields{
                        "pod-id":        pod.id,
                        "container-id":  containerID,
                        "old-cgroup-id": container.cgID,
                        "new-cgroup-id": *cgIDp,
                }).Warnf("AddPodContainer: conflicting cgroup ids")</span>
        }

        <span class="cov8" title="1">return false</span>
}

type policy struct {
        id PolicyID

        // if namespace is "", policy applies to all namespaces
        namespace string

        podSelector labels.Selector

        // polMap is the (inner) policy map for this policy
        polMap polMap
}

func (pol *policy) podMatches(podNs string, podLabels labels.Labels) bool <span class="cov8" title="1">{
        if pol.namespace != "" &amp;&amp; podNs != pol.namespace </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return pol.podSelector.Match(podLabels)</span>
}

func (pol *policy) podInfoMatches(pod *podInfo) bool <span class="cov8" title="1">{
        return pol.podMatches(pod.namespace, pod.labels)
}</span>

// State holds the necessary state for policyfilter
type state struct {
        log logrus.FieldLogger

        // mutex serializes access to the internal structures, as well as operations.
        mu       sync.Mutex
        policies []policy
        pods     []podInfo

        // polify filters (outer) map handle
        pfMap PfMap

        cgidFinder cgidFinder
}

// New creates a new State of the policy filter code. Callers should call Close() to release
// allocated resources (namely the bpf map).
//
//revive:disable:unexported-return
func New() (*state, error) <span class="cov8" title="1">{
        log := logger.GetLogger().WithField("subsystem", "policy-filter")
        return newState(
                log,
                &amp;cgfsFinder{fsscan.New(), log},
        )
}</span>

func newState(
        log logrus.FieldLogger,
        cgidFinder cgidFinder,
) (*state, error) <span class="cov8" title="1">{
        var err error
        ret := &amp;state{
                log:        log,
                cgidFinder: cgidFinder,
        }

        ret.pfMap, err = newPfMap()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return ret, nil</span>
}

//revive:enable:unexported-return

func (m *state) updatePodHandler(pod *v1.Pod) <span class="cov8" title="1">{
        containerIDs := podContainersIDs(pod)
        podID, err := uuid.Parse(string(pod.UID))
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithError(err).WithField("pod-id", pod.UID).Warn("policyfilter, pod handler: failed to parse pod id")
                return
        }</span>

        <span class="cov8" title="1">namespace := pod.Namespace
        podLabels := labels.LabelsFromPod(pod)
        err = m.UpdatePod(PodID(podID), namespace, podLabels, containerIDs)
        if err != nil </span><span class="cov0" title="0">{
                m.log.WithError(err).WithFields(logrus.Fields{
                        "pod-id":        podID,
                        "container-ids": containerIDs,
                        "namespace":     namespace,
                }).Warn("policyfilter, add pod-handler: AddPodContainer failed")
        }</span>
}

func (m *state) getPodEventHandlers() cache.ResourceEventHandlerFuncs <span class="cov8" title="1">{
        return cache.ResourceEventHandlerFuncs{
                AddFunc: func(obj interface{}) </span><span class="cov8" title="1">{
                        pod, ok := obj.(*v1.Pod)
                        if !ok </span><span class="cov0" title="0">{
                                logger.GetLogger().Warn("policyfilter, add-pod handler: unexpected object type: %T", pod)
                                return
                        }</span>
                        <span class="cov8" title="1">m.updatePodHandler(pod)</span>

                },
                UpdateFunc: func(oldObj, newObj interface{}) <span class="cov8" title="1">{
                        pod, ok := newObj.(*v1.Pod)
                        if !ok </span><span class="cov0" title="0">{
                                logger.GetLogger().Warn("policyfilter, update-pod: unexpected object type(s): new:%T", pod)
                                return
                        }</span>
                        <span class="cov8" title="1">m.updatePodHandler(pod)</span>
                },
                DeleteFunc: func(obj interface{}) <span class="cov8" title="1">{
                        // Remove all containers for this pod
                        pod, ok := obj.(*v1.Pod)
                        if !ok </span><span class="cov0" title="0">{
                                logger.GetLogger().Warn("policyfilter, delete-pod handler: unexpected object type: %T", pod)
                                return
                        }</span>
                        <span class="cov8" title="1">podID, err := uuid.Parse(string(pod.UID))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.GetLogger().WithField("pod-id", pod.UID).WithError(err).Warn("policyfilter, delete-pod: failed to parse id")
                                return
                        }</span>

                        <span class="cov8" title="1">namespace := pod.Namespace
                        err = m.DelPod(PodID(podID))
                        if err != nil </span><span class="cov0" title="0">{
                                logger.GetLogger().WithError(err).WithFields(logrus.Fields{
                                        "pod-id":    podID,
                                        "namespace": namespace,
                                }).Warn("policyfilter, delete-pod handler: DelPod failed")
                        }</span>
                },
        }
}

func (m *state) RegisterPodHandlers(podInformer cache.SharedIndexInformer) <span class="cov0" title="0">{
        podInformer.AddEventHandler(m.getPodEventHandlers())
}</span>

// Close releases resources allocated by the Manager. Specifically, we close and unpin the policy filter map.
func (m *state) Close() error <span class="cov8" title="1">{
        return m.pfMap.release()
}</span>

func (m *state) findPolicy(id PolicyID) *policy <span class="cov8" title="1">{
        for i := range m.policies </span><span class="cov8" title="1">{
                if m.policies[i].id == id </span><span class="cov8" title="1">{
                        return &amp;m.policies[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// delPolicy removes a policy and returns it, or returns nil if policy is not found
func (m *state) delPolicy(id PolicyID) *policy <span class="cov8" title="1">{
        for i, pol := range m.policies </span><span class="cov8" title="1">{
                if pol.id == id </span><span class="cov8" title="1">{
                        m.policies = append(m.policies[:i], m.policies[i+1:]...)
                        return &amp;pol
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// find the pod with the given id
func (m *state) findPod(id PodID) *podInfo <span class="cov8" title="1">{
        for i := range m.pods </span><span class="cov8" title="1">{
                if m.pods[i].id == id </span><span class="cov8" title="1">{
                        return &amp;m.pods[i]
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (m *state) delPod(id PodID) *podInfo <span class="cov8" title="1">{
        for i, pod := range m.pods </span><span class="cov8" title="1">{
                if pod.id == id </span><span class="cov8" title="1">{
                        m.pods = append(m.pods[:i], m.pods[i+1:]...)
                        return &amp;pod
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// AddPolicy adds a policy
func (m *state) AddPolicy(polID PolicyID, namespace string, podLabelSelector *slimv1.LabelSelector) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        if p := m.findPolicy(polID); p != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("policy with id %d already exists: not adding new one", polID)
        }</span>

        <span class="cov8" title="1">podSelector, err := labels.SelectorFromLabelSelector(podLabelSelector)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">policy := policy{
                id:          polID,
                namespace:   namespace,
                podSelector: podSelector,
        }

        cgroupIDs := make([]CgroupID, 0)
        // scan pods to find the ones that match this policy to set initial state for policy
        matchedPods := make([]*podInfo, 0, len(m.pods))
        for i := range m.pods </span><span class="cov8" title="1">{
                pod := &amp;m.pods[i]
                if !policy.podInfoMatches(pod) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for cIdx := range pod.containers </span><span class="cov8" title="1">{
                        cgroupIDs = append(cgroupIDs, pod.containers[cIdx].cgID)
                }</span>
                <span class="cov8" title="1">matchedPods = append(matchedPods, pod)
                pod.addCachedPolicy(policy.id)</span>
        }

        // update state for policy
        <span class="cov8" title="1">policy.polMap, err = m.pfMap.newPolicyMap(polID, cgroupIDs)
        if err != nil </span><span class="cov0" title="0">{
                for _, pod := range matchedPods </span><span class="cov0" title="0">{
                        pod.delCachedPolicy(policy.id)
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("adding policy data to map failed: %w", err)</span>
        }

        <span class="cov8" title="1">m.policies = append(m.policies, policy)

        return nil</span>
}

// DelPolicy will destroly all information for the provided policy
func (m *state) DelPolicy(polID PolicyID) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()
        policy := m.delPolicy(polID)
        if policy != nil </span><span class="cov8" title="1">{
                policy.polMap.Close()
        }</span> else<span class="cov0" title="0"> {
                m.log.WithField("policy-id", polID).Warn("DelPolicy: policy internal map not found")
        }</span>

        <span class="cov8" title="1">if err := m.pfMap.Delete(polID); err != nil </span><span class="cov0" title="0">{
                m.log.WithField("policy-id", polID).Warn("DelPolicy: failed to remove policy from external map")
        }</span>

        <span class="cov8" title="1">for i := range m.pods </span><span class="cov8" title="1">{
                pod := &amp;m.pods[i]
                pod.delCachedPolicy(policy.id)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func cgIDPointerStr(p *CgroupID) string <span class="cov0" title="0">{
        if p == nil </span><span class="cov0" title="0">{
                return "(unknown)"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%d", *p)</span>
}

// addPodContainers adds a list of containers (ids) to a pod.
// It will update the state for all containers that do not exist.
// It takes an optional argument of a list of cgroup ids (one per container). If this list is empty,
// the function will try to figure out the cgroup id on its own.
// Finally, it will scan over all the matching policies for the pod and update the policy maps.
func (m *state) addPodContainers(pod *podInfo, containerIDs []string, cgroupIDs []CgroupID) <span class="cov8" title="1">{
        // Find the containers that do not exist in our state, and for those find the cgroup id if
        // one does not exist.
        cinfo := make([]containerInfo, 0, len(containerIDs))
        cgIDs := make([]CgroupID, 0, len(containerIDs))
        for i, contID := range containerIDs </span><span class="cov8" title="1">{
                var cgIDptr *CgroupID
                if len(cgroupIDs) &gt; i </span><span class="cov8" title="1">{
                        cgIDptr = &amp;cgroupIDs[i]
                }</span>

                <span class="cov8" title="1">if m.containerExists(pod, contID, cgIDptr) </span><span class="cov0" title="0">{
                        m.debugLogWithCallers(4).WithFields(logrus.Fields{
                                "pod-id":       pod.id,
                                "namespace":    pod.namespace,
                                "container-id": contID,
                                "cgroup-id":    cgIDPointerStr(cgIDptr),
                        }).Info("addPodContainers: container exists, skipping")
                        continue</span>
                }

                <span class="cov8" title="1">if cgIDptr == nil </span><span class="cov8" title="1">{
                        if cgid, err := m.cgidFinder.findCgroupID(pod.id, contID); err != nil </span><span class="cov0" title="0">{
                                // error: skip this container id
                                m.log.WithError(err).WithFields(logrus.Fields{
                                        "pod-id":       pod.id,
                                        "container-id": contID,
                                }).Warn("failed to find cgroup id. Skipping container.")
                                continue</span>
                        } else<span class="cov8" title="1"> {
                                cgIDptr = &amp;cgid
                        }</span>
                }

                <span class="cov8" title="1">cinfo = append(cinfo, containerInfo{contID, *cgIDptr})
                cgIDs = append(cgIDs, *cgIDptr)</span>
        }

        <span class="cov8" title="1">if len(cinfo) == 0 </span><span class="cov8" title="1">{
                m.debugLogWithCallers(4).WithFields(logrus.Fields{
                        "pod-id":        pod.id,
                        "namespace":     pod.namespace,
                        "container-ids": containerIDs,
                }).Info("addPodContainers: nothing to do, returning")
                return
        }</span>

        // update containers
        <span class="cov8" title="1">pod.containers = append(pod.containers, cinfo...)
        m.debugLogWithCallers(4).WithFields(logrus.Fields{
                "pod-id":          pod.id,
                "namespace":       pod.namespace,
                "containers-info": cinfo,
        }).Info("addPodContainers: container(s) added")

        // update matching policy maps
        for _, policyID := range pod.matchedPolicies </span><span class="cov8" title="1">{
                pol := m.findPolicy(policyID)
                if pol == nil </span><span class="cov0" title="0">{
                        m.log.WithFields(logrus.Fields{
                                "policy-id":  policyID,
                                "pod-id":     pod.id,
                                "cgroup-ids": cgroupIDs,
                        }).Warn("addPodContainers: unknown policy id found in pod. This should not happen, ignoring.")
                        continue</span>
                }

                <span class="cov8" title="1">if err := pol.polMap.addCgroupIDs(cgIDs); err != nil </span><span class="cov0" title="0">{
                        m.log.WithError(err).WithFields(logrus.Fields{
                                "policy-id":  pol.id,
                                "pod-id":     pod.id,
                                "cgroup-ids": cgroupIDs,
                        }).Warn("failed to update policy map")
                }</span>
        }
}

func (m *state) addNewPod(podID PodID, namespace string, podLabels labels.Labels) *podInfo <span class="cov8" title="1">{
        m.pods = append(m.pods, podInfo{
                id:         podID,
                namespace:  namespace,
                labels:     podLabels,
                containers: nil,
        })
        pod := &amp;m.pods[len(m.pods)-1]
        for i := range m.policies </span><span class="cov8" title="1">{
                pol := &amp;m.policies[i]
                if pol.podInfoMatches(pod) </span><span class="cov8" title="1">{
                        pod.addCachedPolicy(pol.id)
                }</span>
        }
        <span class="cov8" title="1">return pod</span>
}

// AddPodContainer informs policyfilter about a new container in a pod.
// if the cgroup id of the container is known, cgID is not nil and it contains its value.
//
// The pod might or might not have been encountered before.
func (m *state) AddPodContainer(podID PodID, namespace string, podLabels labels.Labels, containerID string, cgID CgroupID) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        pod := m.findPod(podID)
        if pod == nil </span><span class="cov8" title="1">{
                pod = m.addNewPod(podID, namespace, podLabels)
                m.debugLogWithCallers(4).WithFields(logrus.Fields{
                        "pod-id":       podID,
                        "namespace":    namespace,
                        "container-id": containerID,
                        "cgroup-id":    cgID,
                }).Info("AddPodContainer: added pod")
        }</span> else<span class="cov8" title="1"> if pod.namespace != namespace </span><span class="cov0" title="0">{
                // sanity check: old and new namespace should match
                return fmt.Errorf("conflicting namespaces for pod with id %s: old='%s' vs new='%s'", podID, pod.namespace, namespace)
        }</span>

        <span class="cov8" title="1">m.addPodContainers(pod, []string{containerID}, []CgroupID{cgID})
        return nil</span>
}

// delPodCgroupIDsFromPolicyMaps will delete cgorup entries for containers belonging to pod on all
// policy maps.
func (m *state) delPodCgroupIDsFromPolicyMaps(pod *podInfo, containers []containerInfo) <span class="cov8" title="1">{

        if len(containers) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">cgroupIDs := make([]CgroupID, 0, len(containers))
        for i := range containers </span><span class="cov8" title="1">{
                cgroupIDs = append(cgroupIDs, containers[i].cgID)
        }</span>

        // check what policies match the pod, and delete the cgroup ids
        <span class="cov8" title="1">for _, policyID := range pod.matchedPolicies </span><span class="cov8" title="1">{
                pol := m.findPolicy(policyID)
                if pol == nil </span><span class="cov0" title="0">{
                        m.log.WithFields(logrus.Fields{
                                "policy-id":  policyID,
                                "pod-id":     pod.id,
                                "cgroup-ids": cgroupIDs,
                        }).Warn("delPodCgroupIDsFromPolicyMaps: unknown policy id found in pod. This should not happen, ignoring.")
                        continue</span>
                }

                <span class="cov8" title="1">if err := pol.polMap.delCgroupIDs(cgroupIDs); err != nil </span><span class="cov0" title="0">{
                        // NB: depending on the error, we might want to schedule some retries here
                        m.log.WithError(err).WithFields(logrus.Fields{
                                "policy-id":  pol.id,
                                "pod-id":     pod.id,
                                "cgroup-ids": cgroupIDs,
                        }).Warn("delPodCgroupIDsFromPolicyMaps: failed to delete cgroup ids from policy map")
                }</span>
        }
}

// DelPodContainer informs policyfilter that a container was deleted from a pod
func (m *state) DelPodContainer(podID PodID, containerID string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        pod := m.findPod(podID)
        if pod == nil </span><span class="cov0" title="0">{
                m.Debugf("DelPodContainer: pod-id %s not found", podID)
                return nil
        }</span>

        <span class="cov8" title="1">containers := pod.delContainers(containerID)
        if len(containers) != 1 </span><span class="cov0" title="0">{
                m.Debugf("DelPodContainer: pod-id=%s container-id=%s had %d containers: %v", podID, containerID, len(containers), containers)
        }</span>
        <span class="cov8" title="1">m.delPodCgroupIDsFromPolicyMaps(pod, containers)
        return nil</span>
}

// DelPod informs policyfilter that a pod has been deleted
func (m *state) DelPod(podID PodID) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        pod := m.delPod(podID)
        if pod == nil </span><span class="cov0" title="0">{
                m.Debug("DelPod: pod-id %s not found", podID)
                return nil
        }</span>
        <span class="cov8" title="1">m.delPodCgroupIDsFromPolicyMaps(pod, pod.containers)
        return nil</span>
}

// policiesDiffRes is the result returned by policiesDiff
type policiesDiffRes struct {
        // addedPolicies is a slice of the policies that were added
        addedPolicies []*policy
        // deletedPolicies is a slice of the policies that were removed
        deletedPolicies []*policy
        // newMatchedPolicies is a slice of the policy ids that now match the pod
        newMatchedPolicies []PolicyID
}

func (m *state) policiesDiff(pod *podInfo, newLabels labels.Labels) *policiesDiffRes <span class="cov8" title="1">{
        addedPolicies := []*policy{}
        deletedPolicies := []*policy{}
        newMatchedPolicies := []PolicyID{}
        for i := range m.policies </span><span class="cov8" title="1">{
                pol := &amp;m.policies[i]
                podHasPolicy := pod.hasPolicy(pol.id)
                if pol.podMatches(pod.namespace, newLabels) </span><span class="cov8" title="1">{
                        newMatchedPolicies = append(newMatchedPolicies, pol.id)
                        if !podHasPolicy </span><span class="cov8" title="1">{
                                // policy matches, but pod does not have it in its matched policies.
                                addedPolicies = append(addedPolicies, pol)
                        }</span>
                } else<span class="cov8" title="1"> if podHasPolicy </span><span class="cov8" title="1">{
                        // policy does not match, but pod already has it as matched
                        deletedPolicies = append(deletedPolicies, pol)
                }</span>
        }

        <span class="cov8" title="1">return &amp;policiesDiffRes{
                addedPolicies:      addedPolicies,
                deletedPolicies:    deletedPolicies,
                newMatchedPolicies: newMatchedPolicies,
        }</span>
}

// applyPodPolicyDiff applies the changes of the policies that match a pod to the state by updating:
// - the policy maps
//     - adding cgroup ids for policies that match now, but did not match before
//     - removing cgroup ids for policies that did not match, but did match before
// - pod.matchedPolicies with a slice of the new policy ids
func (m *state) applyPodPolicyDiff(pod *podInfo, polDiff *policiesDiffRes) <span class="cov8" title="1">{
        // no changes, just return
        if len(polDiff.addedPolicies) == 0 &amp;&amp; len(polDiff.deletedPolicies) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">cgroupIDs := pod.cgroupIDs()
        for _, addPol := range polDiff.addedPolicies </span><span class="cov8" title="1">{
                if err := addPol.polMap.addCgroupIDs(cgroupIDs); err != nil </span><span class="cov0" title="0">{
                        m.log.WithError(err).WithFields(logrus.Fields{
                                "policy-id":  addPol.id,
                                "pod-id":     pod.id,
                                "cgroup-ids": cgroupIDs,
                                "reason":     "labels change caused policy to match",
                        }).Warn("failed to update policy map")
                }</span>
        }

        <span class="cov8" title="1">for _, delPol := range polDiff.deletedPolicies </span><span class="cov8" title="1">{
                if err := delPol.polMap.delCgroupIDs(cgroupIDs); err != nil </span><span class="cov0" title="0">{
                        m.log.WithError(err).WithFields(logrus.Fields{
                                "policy-id":  delPol.id,
                                "pod-id":     pod.id,
                                "cgroup-ids": cgroupIDs,
                                "reason":     "labels change caused policy to unmatch",
                        }).Warn("failed to update policy map")
                }</span>
        }
        <span class="cov8" title="1">pod.matchedPolicies = polDiff.newMatchedPolicies</span>
}

func (pod *podInfo) containerDiff(newContainerIDs []string) ([]string, []string) <span class="cov8" title="1">{

        // maintain a hash of new ids. The values indicate whether the id was seen in existing ids
        // or not
        newIDs := make(map[string]bool)
        for _, cid := range newContainerIDs </span><span class="cov8" title="1">{
                newIDs[cid] = false
        }</span>

        <span class="cov8" title="1">addContIDs := []string{}
        delContIDs := []string{}
        for _, containerInfo := range pod.containers </span><span class="cov8" title="1">{
                cid := containerInfo.id
                if _, exists := newIDs[cid]; exists </span><span class="cov8" title="1">{
                        newIDs[cid] = true
                }</span> else<span class="cov8" title="1"> {
                        delContIDs = append(delContIDs, cid)
                }</span>
        }

        <span class="cov8" title="1">for cid, seen := range newIDs </span><span class="cov8" title="1">{
                if !seen </span><span class="cov8" title="1">{
                        addContIDs = append(addContIDs, cid)
                }</span>
        }

        <span class="cov8" title="1">return addContIDs, delContIDs</span>
}

// UpdatePod updates the pod state for a pod
// containerIDs contains all the container ids for the given pod.
// so this function will:
//   - remove the containers that are not part of the containerIDs list
//   - add the ones that do not exist in the current state
// It is intended to be used from k8s watchers (where no cgroup information is available)
func (m *state) UpdatePod(podID PodID, namespace string, podLabels labels.Labels, containerIDs []string) error <span class="cov8" title="1">{
        m.mu.Lock()
        defer m.mu.Unlock()

        dlog := m.debugLogWithCallers(4).WithFields(logrus.Fields{
                "pod-id":        podID,
                "namespace":     namespace,
                "container-ids": containerIDs,
        })

        pod := m.findPod(podID)
        if pod == nil </span><span class="cov8" title="1">{
                pod = m.addNewPod(podID, namespace, podLabels)
                dlog.Info("UpdatePod: added pod")
        }</span> else<span class="cov8" title="1"> if pod.namespace != namespace </span><span class="cov0" title="0">{
                // sanity check: old and new namespace should match
                return fmt.Errorf("conflicting namespaces for pod with id %s: old='%s' vs new='%s'", podID, pod.namespace, namespace)
        }</span>

        // labels changed: check if there are policies ads that:
        // - did not match before, but they match now (addPols)
        // - did match before, but they do not match now (delPols))
        // and update state accordingly
        <span class="cov8" title="1">if pod.labels.Cmp(podLabels) </span><span class="cov8" title="1">{
                polDiff := m.policiesDiff(pod, podLabels)
                m.debugLogWithCallers(1).WithFields(logrus.Fields{
                        "pod-id":         pod.id,
                        "pod-old-labels": pod.labels,
                        "pod-new-labels": podLabels,
                        "policy-diff":    fmt.Sprintf("%+v", polDiff),
                }).Info("UpdatePod: pod labels changed")
                m.applyPodPolicyDiff(pod, polDiff)
                pod.labels = podLabels
        }</span>

        // containers changed: check if there are new or deleted containers, and update the policy
        // map
        <span class="cov8" title="1">addIDs, delIDs := pod.containerDiff(containerIDs)
        for _, cid := range delIDs </span><span class="cov8" title="1">{
                containers := pod.delContainers(cid)
                if len(containers) != 1 </span><span class="cov0" title="0">{
                        m.Debugf("UpdatePod: pod-id=%s container-id=%s had %d containers: %v", podID, cid, len(containers), containers)
                }</span>
                <span class="cov8" title="1">m.delPodCgroupIDsFromPolicyMaps(pod, containers)</span>
        }

        <span class="cov8" title="1">m.addPodContainers(pod, addIDs, nil)
        return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
